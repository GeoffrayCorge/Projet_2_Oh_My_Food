Chaque fichier suivi peut avoir l’un de ces trois états :

Modifié (“modified”) ; // nouveau fichier ou fichier non indexé
Indexé (“staged”) ; // suivi par git
Validé (“committed”). // on fige un état, pour éventuellement y revenir


#######################
# commandes principales
#######################

# Lance git: un dossier .git va se créer à la racine de votre projet
# on est positionné sur la branche principale: main
git init


# vos infos à definir car demandées à chaque commit
git config --global user.email "you@example.com"
git config --global user.name "Your Name"


# Ajoute le contenu de votre dossier dans l'environnement git (fichiers suivis)
git add *
# sinon pour un fichier
gt add "votre fichier"

# Prend une photo de votre projet à un instant T
/ permettra de revenir ou avancer dans les differentes versions d'un fichier ou projet
git commit
# il sera preferable d'y indiquer un message precisant quelles ont été les modifs
git commit -m "ici vos commentaires"


# git add et git commit = git commit -a

# permet de connaître rapidement l'état dans lequel est le dépôt.
git status


# supprimer un fichier du suivi
git rm lefichier ?? fonctionne pas

# exclure le fichier du suivi git
git rm --cached <le-fichier>


# retirer un fichier du suivi
# on peut vouloir qu'un fichier ne fasse pas partie du prochain commit
# car on l'a ajouté par erreur
git reset HEAD <nom-du-fichier>



# Empêcher l’indexation de certains fichiers dans Git
Créer un fichier .gitignore et en ajoutant les différents fichiers qu’on souhaite ignorer.
Notez qu’on peut également mentionner des schémas de noms pour exclure tous les fichiers correspondant à ce schéma
et qu’on peut même exclure le contenu entier d’un répertoire en écrivant le chemin du répertoire suivi d’un slash.


# Renommer un fichier dans Git
git mv ancien-nom-fichier nouveau-nom-fichier.


# Consulter l’historique des modifications Git (commit)
git log
git log -p #permet d’afficher explicitement les différences introduites entre chaque validation.
git log --pretty=oneline  #affiche tous les commit
git log --since #permet de n’afficher que les modifications depuis une certaine date (on peut lui fournir différents formats de date comme 2.weeks ou 2019-10-10 par exemple).
git log --author  # affiche les commit d'un auteur
git diff <commit1_id> <commit2_id> # differences entre 2 commit


#Ecraser le precedent commit si commit par erreur (apres un git commit)
git add
git commit --amend


# restaurer la derniere version
git restore fichier
#ou
git checkout -- fichier


#revenir à un ancienne version
git checkout <commit_id>

###########################################

# Créer une branche
# Par defaut la branche principale s'appelle main
# généralement, on va créer de nouvelles branches pour travailler sur de nouvelles fonctionnalités pour notre projet sans impacter la ligne de développement principale
git branch nomdenotrebranche

# Pointer vers une branche
git checkout nomdenotrebranche

# Supprimer un branche
git checkout -d nomdenotrebranche

# Fusionner des branches
# On va donc développer nos fonctionnalités sur des branches connexes et les tester jusqu’à ce qu’on soit sûrs qu’il n’y a pas de problème
# et on va finalement réintégrer ces fonctionnalités développées au sein de notre ligne de développement principale.

# cas d'un commit forward (pas de problème de divergence)
# commit main = N
# commit nomdenotrebranche = N+1

# 1)on reviens sur la branche principale
git checkout main
# 2) on fusionne notre branche à la branche principale
git merge nomdenotrebranche

# cas d'un commit forward
# commit main = N
# commit nomdenotrebranche = N+1

# cas de deux branches dont les historiques divergent
# commit main = N+2
# commit nomdenotrebranche = N+1
# possibilité de conflits si des branches différentes travaillent sur le même script
# dans ce cas là git prévient qu'il y a un probleme
# pour voir le probleme
git status
# si 2 dev travaillent sur le même script: les 2 scripts apparaitront lors de la fusion
# il faudra corriger le problème et faire
git add versioncorrigee
git commit

##################################################

# Rebaser une branche
#cad récupérer les modifications validées sur une branche et les rejouer sur une autre.
git rebase

# Le résultat final est le même qu’avec une fusion mais l’historique est plus clair puisque toutes les modifications apparaissent en série même si elles ont eu lieu en parallèle.
# Rebaser rejoue les modifications d’une ligne de commits sur une autre dans l’ordre d’apparition, alors que la fusion joint et fusionne les deux têtes.
# ATTENTION
# rebaser équivaut à supprimer des commits existants pour en créer de nouveaux (qui sont similaires de par leur contenu mais qui sont bien des entités différentes).
# Pour cette raison, vous ne devez jamais rebaser des commits qui ont déjà été poussés sur un dépôt public.



##########
# gitHub
##########

# faire un depot
# crée le lien avec votre repo sur gitHub
git remote add origin https://github.com/pcuccura/oclock.git

# on se connecte sur la branche principale
git branch -M main

# synchronise votre dossier local avec votre repo sur gitHub
git push -u origin main

# recupere un projet: le dossier de reception doit etre deja créé
git pull

# recupere un projet = init + remote + pull
git clone <URL>

# copie d’un dépôt distant qui nous permet d’effectuer des modifications sans affecter le projet original.
git fork <URL>
# on crée notre branche (voir branch)
# un fois notre contribution terminée si on est connecté (voir remote)
# on fait un pull pour la soumettre à l'auteur qui l'accepte ou pas

# permet de connaître rapidement l'état dans lequel est le dépôt.
git status

















